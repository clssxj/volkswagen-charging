# 静态数据逻辑说明

## 🎯 核心设计原则

充电桩是**客观存在的物理设施**，因此数据应该具有以下特性：

✅ **位置固定**：充电桩的经纬度坐标不会变化  
✅ **名称固定**：充电站名称和地址不会变化  
✅ **总数固定**：每个站点的充电桩总数不会变化  
✅ **数量动态**：空闲桩数会随使用情况变化  
✅ **价格动态**：电价会根据时段变化（峰谷电价）  

---

## 📊 数据结构

### 静态数据（不变）

```javascript
{
  id: "hefei_station_1",          // 固定ID
  name: "合肥商场中心充电站",      // 固定名称
  lat: 31.856234,                  // 固定纬度
  lng: 117.265123,                 // 固定经度
  address: "合肥市蜀山区金寨路123号", // 固定地址
  totalCount: 12,                  // 固定：总充电桩数
  hasAC: true,                     // 固定：是否有交流桩
  hasDC: true,                     // 固定：是否有直流桩
  maxPower: 120,                   // 固定：最大功率
  basePricePerKWh: 1.50,          // 固定：基础电价
  serviceFee: 0.70,                // 固定：服务费
  operatorId: 1                    // 固定：运营商
}
```

### 动态数据（会变化）

```javascript
{
  availableCount: 8,               // 动态：空闲桩数（10-15分钟变化一次）
  chargingCount: 3,                // 动态：充电中数量
  offlineCount: 1,                 // 动态：离线数量
  status: "available",             // 动态：整体状态
  pricePerKWh: 1.65,              // 动态：当前电价（每小时变化）
  _lastAvailableUpdate: 1697520000, // 内部：上次数量更新时间
  _lastPriceUpdate: 1697520000      // 内部：上次价格更新时间
}
```

---

## 🗺️ 数据生成策略

### 一次性生成（应用启动时）

```javascript
应用启动
    ↓
调用 generateHefeiStations()
    ↓
生成合肥市2000个固定充电站
    ↓
存储在 mockStationData.stations
    ↓
后续只从这个数组读取/过滤，不再生成
```

### 区域分布

| 区域 | 充电站数量 | 中心坐标 | 分布半径 |
|------|-----------|---------|---------|
| 蜀山区 | 400 | (31.85, 117.26) | 5km |
| 庐阳区 | 300 | (31.88, 117.27) | 5km |
| 瑶海区 | 300 | (31.86, 117.32) | 5km |
| 包河区 | 400 | (31.78, 117.31) | 5km |
| 高新区 | 200 | (31.84, 117.17) | 5km |
| 经开区 | 200 | (31.77, 117.22) | 5km |
| 新站区 | 100 | (31.92, 117.30) | 5km |
| 滨湖新区 | 100 | (31.72, 117.28) | 5km |
| **总计** | **2000** | - | - |

---

## ⏰ 更新机制

### 1. 充电桩数量更新（每10-15分钟）

```javascript
触发时机：10-15分钟随机间隔

更新逻辑：
1. 遍历所有充电站
2. 检查上次更新时间
3. 如果间隔 >= 10-15分钟：
   - 随机变化：-3 到 +3
   - availableCount += change
   - 限制范围：0 到 totalCount
   - 重新计算 chargingCount
   - 更新状态（available/busy/offline）
   - 记录更新时间
4. 通过WebSocket推送更新
```

**变化规则**：
```javascript
const change = Math.floor(Math.random() * 7) - 3 // -3, -2, -1, 0, 1, 2, 3

新空闲数 = 当前空闲数 + change
新空闲数 = Math.max(0, Math.min(totalCount, 新空闲数))
```

### 2. 价格更新（每小时）

```javascript
触发时机：整点时刻

价格倍率（根据时段）：
- 00:00-06:00 → 0.7倍（深夜低谷）
- 06:00-08:00 → 1.0倍（平时段）
- 08:00-11:00 → 1.5倍（早高峰）
- 11:00-17:00 → 1.0倍（平时段）
- 17:00-22:00 → 1.6倍（晚高峰）
- 22:00-24:00 → 1.0倍（平时段）

计算公式：
当前价格 = 基础价格 × 时段倍率

示例：
基础价格 1.50元/度
- 深夜(3点)：1.50 × 0.7 = 1.05元/度
- 早高峰(9点)：1.50 × 1.5 = 2.25元/度
- 晚高峰(19点)：1.50 × 1.6 = 2.40元/度
```

---

## 🔄 实时更新流程

### WebSocket推送

```
WebSocket定时器
    ↓
每10-15分钟
    ↓
调用 updateStationAvailability()
    ↓
返回有变化的充电站列表
    ↓
推送 'station_status_update' 事件
    ↓
前端接收 → Store更新 → 组件重新渲染
    ↓
标记颜色平滑过渡（0.5s动画）
```

```
WebSocket定时器
    ↓
每小时
    ↓
调用 updateStationPrices()
    ↓
更新所有充电站价格
    ↓
推送 'price_update' 事件
    ↓
前端接收 → 重新加载数据 → 更新标记
```

---

## 🎨 地图缩放逻辑

### 缩放时的行为

```javascript
用户缩放地图
    ↓
触发 'zoomend' 事件
    ↓
调用 handleMapMove()
    ↓
更新地图边界信息（不重新请求数据）
    ↓
调用 updateMarkers()
    ↓
根据缩放级别决定：聚合显示 or 直接显示
    ↓
重新渲染标记（使用已有数据，不重新生成）
```

**关键点**：
- ✅ 使用已有的充电站数据
- ✅ 只改变显示方式（聚合/非聚合）
- ✅ 数据本身不变化
- ✅ 标记内容不变化（除非收到WebSocket更新）

---

## 📍 地图拖动逻辑

### 拖动时的行为

```javascript
用户拖动地图
    ↓
触发 'moveend' 事件
    ↓
防抖处理（延迟500ms）
    ↓
获取新的地图边界
    ↓
调用 fetchStations(bounds)
    ↓
从固定的2000个充电站中过滤
    ↓
返回边界内的充电站
    ↓
更新标记显示
```

**关键点**：
- ✅ 从固定的2000个数据中过滤
- ✅ 不重新生成数据
- ✅ 边界外的充电站不显示
- ✅ 边界内的充电站显示出来

---

## 🔍 数据过滤逻辑

### API调用

```javascript
// src/api/station.js

async getStations(params) {
  // 使用固定的2000个充电站
  let stations = mockStationData.stations
  
  // 根据边界过滤（不重新生成）
  if (params.minLat && params.maxLat && params.minLng && params.maxLng) {
    stations = stations.filter(station => 
      station.lat >= params.minLat &&
      station.lat <= params.maxLat &&
      station.lng >= params.minLng &&
      station.lng <= params.maxLng
    )
  }
  
  return stations
}
```

**示例**：
- 地图显示蜀山区 → 返回约400个充电站
- 地图显示包河区 → 返回约400个充电站
- 地图显示整个合肥 → 返回约2000个充电站
- 地图显示其他城市 → 返回0个充电站（因为只有合肥的数据）

---

## ⚙️ 配置参数

### 更新频率

```javascript
// 可用数量更新
const availabilityUpdateInterval = (10 + Math.random() * 5) * 60 * 1000
// 10-15分钟，随机

// 价格更新
const priceUpdateInterval = 60 * 60 * 1000
// 固定1小时
```

### 数量变化范围

```javascript
const change = Math.floor(Math.random() * 7) - 3
// 变化范围：-3, -2, -1, 0, 1, 2, 3
```

### 价格倍率

```javascript
// 峰谷电价倍率
深夜低谷 (0-6点)    → 0.7倍
平时段 (6-8点)      → 1.0倍
早高峰 (8-11点)     → 1.5倍
平时段 (11-17点)    → 1.0倍
晚高峰 (17-22点)    → 1.6倍
平时段 (22-24点)    → 1.0倍
```

---

## 📝 控制台输出

### 启动时

```
已生成合肥市 2000 个固定充电站
启动Mock模式：充电桩状态和价格自动更新
价格已根据时段更新
下次充电桩数量更新将在 12 分钟后
```

### 运行时

```
// 每10-15分钟
推送 85 个充电站的数量更新
下次充电桩数量更新将在 14 分钟后

// 每小时
价格已根据时段更新
价格已更新，重新加载充电站数据
```

### 缩放/拖动时

```
// 只是过滤，不重新生成
返回 234 个充电站数据（边界过滤）
已加载 234 个充电站标记（聚合模式）
```

---

## ✅ 解决的问题

### 问题1：每次缩放都重新生成数据 ❌

**旧逻辑**：
```
缩放地图 → 获取边界 → 动态生成新数据 → 数据跳动
```

**新逻辑**：
```
缩放地图 → 获取边界 → 从固定数据过滤 → 数据稳定 ✓
```

### 问题2：充电桩位置随机跳动 ❌

**旧逻辑**：
```
每次请求都随机生成坐标 → 位置不固定
```

**新逻辑**：
```
启动时生成一次 → 坐标固定 → 永不变化 ✓
```

### 问题3：更新频率过高 ❌

**旧逻辑**：
```
每5-10秒推送更新 → 太频繁，不真实
```

**新逻辑**：
```
每10-15分钟推送数量更新 → 符合实际 ✓
每1小时更新价格 → 峰谷电价 ✓
```

---

## 🧪 测试验证

### 1. 启动应用

```bash
npm run dev
```

访问：https://localhost:3000

### 2. 观察控制台

应该看到：
```
✓ 已生成合肥市 2000 个固定充电站
✓ 启动Mock模式：充电桩状态和价格自动更新
✓ 价格已根据时段更新
```

### 3. 查看地图

- ✅ 地图中心：合肥市
- ✅ 显示充电站标记
- ✅ 标记颜色：绿/黄/红/灰
- ✅ 标记内容：图标+价格+空闲数

### 4. 缩放地图

**操作**：双指缩放或点击+/-按钮

**预期**：
- ✅ 标记位置不变
- ✅ 标记内容不变
- ✅ 只改变显示方式（聚合↔单独）
- ✅ 控制台不显示"动态生成"

### 5. 拖动地图

**操作**：拖动到不同区域

**预期**：
- ✅ 显示该区域的充电站
- ✅ 离开区域的充电站消失
- ✅ 再拖回来，充电站还在原位
- ✅ 控制台显示"返回 XX 个充电站数据（边界过滤）"

### 6. 等待更新

**5秒后**：
```
推送 XX 个充电站的数量更新
```
- 部分充电站的空闲桩数变化（±0-3个）
- 标记颜色可能变化（如果空闲率跨越阈值）
- 变化平滑（0.5s过渡动画）

**1小时后**：
```
价格已根据时段更新
```
- 所有充电站价格根据时段调整
- 标记上的价格文字更新

---

## 📊 数据一致性

### 保证措施

1. **单例数据源**
   ```javascript
   const HEFEI_STATIONS = generateHefeiStations() // 只生成一次
   ```

2. **引用传递**
   ```javascript
   // 所有API返回的都是同一个数组的引用或过滤结果
   mockStationData.stations = HEFEI_STATIONS
   ```

3. **原地更新**
   ```javascript
   // 更新时直接修改对象属性，不创建新对象
   station.availableCount = newValue
   station.pricePerKWh = newPrice
   ```

4. **时间戳记录**
   ```javascript
   // 记录每个充电站的上次更新时间，避免重复更新
   station._lastAvailableUpdate = Date.now()
   station._lastPriceUpdate = Date.now()
   ```

---

## 🎮 用户体验

### 正常场景

```
用户打开应用
    ↓
看到合肥市2000个固定充电站
    ↓
标记稳定显示，位置不跳动
    ↓
缩放地图 → 标记位置不变
拖动地图 → 标记稳定，只是过滤显示
    ↓
5秒后 → 少数充电站空闲数变化
10-15分钟 → 部分充电站空闲数变化
1小时 → 价格根据时段变化
```

### 异常场景

**如果用户不在合肥**：
- 定位到北京 → 地图移动到北京
- 但数据只有合肥 → 看不到充电站
- 解决方案：拖动地图到合肥，或等待后续添加其他城市数据

---

## 🔧 后续扩展

### 添加其他城市数据

如需支持其他城市，只需修改：

```javascript
// src/api/mock/station-mock.js

const ALL_STATIONS = [
  ...generateHefeiStations(),      // 合肥2000个
  ...generateBeijingStations(),    // 北京2000个
  ...generateShanghaiStations(),   // 上海2000个
  // ...
]
```

### 真实数据对接

当对接真实后端时：

```javascript
// .env
VITE_USE_MOCK=false
```

真实API应该返回同样的数据结构，但数据来自数据库而非Mock生成。

---

## 📚 相关文件

| 文件 | 说明 |
|------|------|
| `src/api/mock/station-mock.js` | 静态数据生成和更新逻辑 |
| `src/api/station.js` | API调用（过滤而非生成） |
| `src/services/websocket.js` | 定时推送更新 |
| `src/views/MapView.vue` | 监听更新事件 |
| `src/stores/station.js` | 状态管理和更新 |

---

## 🎯 总结

### 核心改进

| 方面 | 旧方案 | 新方案 |
|------|-------|--------|
| 数据生成 | 每次请求生成 | 启动时生成一次 |
| 位置稳定性 | 随机跳动 | 完全固定 |
| 缩放行为 | 重新生成 | 仅过滤显示 |
| 更新频率 | 5-10秒 | 10-15分钟 |
| 价格变化 | 固定 | 每小时根据时段 |
| 真实性 | 低 | 高 |

### 符合实际

✅ 充电桩是固定设施，位置不会变  
✅ 空闲桩数随使用情况变化  
✅ 价格实行峰谷电价，分时段  
✅ 更新频率合理，符合实际业务  

---

**文档版本**: v3.0.0  
**更新时间**: 2024-10-17  
**状态**: ✅ 完成

